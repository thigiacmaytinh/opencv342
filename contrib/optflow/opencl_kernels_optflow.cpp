// This file is auto-generated. Do not edit!

#include "opencv2/core.hpp"
#include "cvconfig.h"
#include "opencl_kernels_optflow.hpp"

#ifdef HAVE_OPENCL

namespace cv
{
namespace ocl
{
namespace optflow
{

static const char* const moduleName = "optflow";

struct cv::ocl::internal::ProgramEntry dis_flow_oclsrc={moduleName, "dis_flow",
"#define EPS 0.001f\n"
"#define INF 1E+10F\n"
"__kernel void dis_precomputeStructureTensor_hor(__global const short *I0x,\n"
"__global const short *I0y,\n"
"int patch_size, int patch_stride,\n"
"int w, int h, int ws,\n"
"__global float *I0xx_aux_ptr,\n"
"__global float *I0yy_aux_ptr,\n"
"__global float *I0xy_aux_ptr,\n"
"__global float *I0x_aux_ptr,\n"
"__global float *I0y_aux_ptr)\n"
"{\n"
"int i = get_global_id(0);\n"
"if (i >= h) return;\n"
"const __global short *x_row = I0x + i * w;\n"
"const __global short *y_row = I0y + i * w;\n"
"float sum_xx = 0.0f, sum_yy = 0.0f, sum_xy = 0.0f, sum_x = 0.0f, sum_y = 0.0f;\n"
"float8 x_vec = convert_float8(vload8(0, x_row));\n"
"float8 y_vec = convert_float8(vload8(0, y_row));\n"
"sum_xx = dot(x_vec.lo, x_vec.lo) + dot(x_vec.hi, x_vec.hi);\n"
"sum_yy = dot(y_vec.lo, y_vec.lo) + dot(y_vec.hi, y_vec.hi);\n"
"sum_xy = dot(x_vec.lo, y_vec.lo) + dot(x_vec.hi, y_vec.hi);\n"
"sum_x = dot(x_vec.lo, 1.0f) + dot(x_vec.hi, 1.0f);\n"
"sum_y = dot(y_vec.lo, 1.0f) + dot(y_vec.hi, 1.0f);\n"
"I0xx_aux_ptr[i * ws] = sum_xx;\n"
"I0yy_aux_ptr[i * ws] = sum_yy;\n"
"I0xy_aux_ptr[i * ws] = sum_xy;\n"
"I0x_aux_ptr[i * ws] = sum_x;\n"
"I0y_aux_ptr[i * ws] = sum_y;\n"
"int js = 1;\n"
"for (int j = patch_size; j < w; j++)\n"
"{\n"
"short x_val1 = x_row[j];\n"
"short x_val2 = x_row[j - patch_size];\n"
"short y_val1 = y_row[j];\n"
"short y_val2 = y_row[j - patch_size];\n"
"sum_xx += (x_val1 * x_val1 - x_val2 * x_val2);\n"
"sum_yy += (y_val1 * y_val1 - y_val2 * y_val2);\n"
"sum_xy += (x_val1 * y_val1 - x_val2 * y_val2);\n"
"sum_x += (x_val1 - x_val2);\n"
"sum_y += (y_val1 - y_val2);\n"
"if ((j - patch_size + 1) % patch_stride == 0)\n"
"{\n"
"int index = i * ws + js;\n"
"I0xx_aux_ptr[index] = sum_xx;\n"
"I0yy_aux_ptr[index] = sum_yy;\n"
"I0xy_aux_ptr[index] = sum_xy;\n"
"I0x_aux_ptr[index] = sum_x;\n"
"I0y_aux_ptr[index] = sum_y;\n"
"js++;\n"
"}\n"
"}\n"
"}\n"
"__kernel void dis_precomputeStructureTensor_ver(__global const float *I0xx_aux_ptr,\n"
"__global const float *I0yy_aux_ptr,\n"
"__global const float *I0xy_aux_ptr,\n"
"__global const float *I0x_aux_ptr,\n"
"__global const float *I0y_aux_ptr,\n"
"int patch_size, int patch_stride,\n"
"int w, int h, int ws,\n"
"__global float *I0xx_ptr,\n"
"__global float *I0yy_ptr,\n"
"__global float *I0xy_ptr,\n"
"__global float *I0x_ptr,\n"
"__global float *I0y_ptr)\n"
"{\n"
"int j = get_global_id(0);\n"
"if (j >= ws) return;\n"
"float sum_xx, sum_yy, sum_xy, sum_x, sum_y;\n"
"sum_xx = sum_yy = sum_xy = sum_x = sum_y = 0.0f;\n"
"for (int i = 0; i < patch_size; i++)\n"
"{\n"
"sum_xx += I0xx_aux_ptr[i * ws + j];\n"
"sum_yy += I0yy_aux_ptr[i * ws + j];\n"
"sum_xy += I0xy_aux_ptr[i * ws + j];\n"
"sum_x  += I0x_aux_ptr[i * ws + j];\n"
"sum_y  += I0y_aux_ptr[i * ws + j];\n"
"}\n"
"I0xx_ptr[j] = sum_xx;\n"
"I0yy_ptr[j] = sum_yy;\n"
"I0xy_ptr[j] = sum_xy;\n"
"I0x_ptr[j] = sum_x;\n"
"I0y_ptr[j] = sum_y;\n"
"int is = 1;\n"
"for (int i = patch_size; i < h; i++)\n"
"{\n"
"sum_xx += (I0xx_aux_ptr[i * ws + j] - I0xx_aux_ptr[(i - patch_size) * ws + j]);\n"
"sum_yy += (I0yy_aux_ptr[i * ws + j] - I0yy_aux_ptr[(i - patch_size) * ws + j]);\n"
"sum_xy += (I0xy_aux_ptr[i * ws + j] - I0xy_aux_ptr[(i - patch_size) * ws + j]);\n"
"sum_x  += (I0x_aux_ptr[i * ws + j] - I0x_aux_ptr[(i - patch_size) * ws + j]);\n"
"sum_y  += (I0y_aux_ptr[i * ws + j] - I0y_aux_ptr[(i - patch_size) * ws + j]);\n"
"if ((i - patch_size + 1) % patch_stride == 0)\n"
"{\n"
"I0xx_ptr[is * ws + j] = sum_xx;\n"
"I0yy_ptr[is * ws + j] = sum_yy;\n"
"I0xy_ptr[is * ws + j] = sum_xy;\n"
"I0x_ptr[is * ws + j] = sum_x;\n"
"I0y_ptr[is * ws + j] = sum_y;\n"
"is++;\n"
"}\n"
"}\n"
"}\n"
"__kernel void dis_densification(__global const float *sx, __global const float *sy,\n"
"__global const uchar *i0, __global const uchar *i1,\n"
"int psz, int pstr,\n"
"int w, int h, int ws,\n"
"__global float *ux, __global float *uy)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int i, j;\n"
"if (x >= w || y >= h) return;\n"
"int start_is, end_is;\n"
"int start_js, end_js;\n"
"end_is = min(y / pstr, (h - psz) / pstr);\n"
"start_is = max(0, y - psz + pstr) / pstr;\n"
"start_is = min(start_is, end_is);\n"
"end_js = min(x / pstr, (w - psz) / pstr);\n"
"start_js = max(0, x - psz + pstr) / pstr;\n"
"start_js = min(start_js, end_js);\n"
"float coef, sum_coef = 0.0f;\n"
"float sum_Ux = 0.0f;\n"
"float sum_Uy = 0.0f;\n"
"int i_l, i_u;\n"
"int j_l, j_u;\n"
"float i_m, j_m, diff;\n"
"i = y;\n"
"j = x;\n"
"for (int is = start_is; is <= end_is; is++)\n"
"for (int js = start_js; js <= end_js; js++)\n"
"{\n"
"float sx_val = sx[is * ws + js];\n"
"float sy_val = sy[is * ws + js];\n"
"uchar2 i1_vec1, i1_vec2;\n"
"j_m = min(max(j + sx_val, 0.0f), w - 1.0f - EPS);\n"
"i_m = min(max(i + sy_val, 0.0f), h - 1.0f - EPS);\n"
"j_l = (int)j_m;\n"
"j_u = j_l + 1;\n"
"i_l = (int)i_m;\n"
"i_u = i_l + 1;\n"
"i1_vec1 = vload2(0, i1 + i_u * w + j_l);\n"
"i1_vec2 = vload2(0, i1 + i_l * w + j_l);\n"
"diff = (j_m - j_l) * (i_m - i_l) * i1_vec1.y +\n"
"(j_u - j_m) * (i_m - i_l) * i1_vec1.x +\n"
"(j_m - j_l) * (i_u - i_m) * i1_vec2.y +\n"
"(j_u - j_m) * (i_u - i_m) * i1_vec2.x - i0[i * w + j];\n"
"coef = 1 / max(1.0f, fabs(diff));\n"
"sum_Ux += coef * sx_val;\n"
"sum_Uy += coef * sy_val;\n"
"sum_coef += coef;\n"
"}\n"
"ux[i * w + j] = sum_Ux / sum_coef;\n"
"uy[i * w + j] = sum_Uy / sum_coef;\n"
"}\n"
"#define INIT_BILINEAR_WEIGHTS(Ux, Uy)                                                                                  \\\n"
"i_I1 = min(max(i + Uy + bsz, i_lower_limit), i_upper_limit);                                                       \\\n"
"j_I1 = min(max(j + Ux + bsz, j_lower_limit), j_upper_limit);                                                       \\\n"
"\\\n"
"w11 = (i_I1 - floor(i_I1)) * (j_I1 - floor(j_I1));                                                                 \\\n"
"w10 = (i_I1 - floor(i_I1)) * (floor(j_I1) + 1 - j_I1);                                                             \\\n"
"w01 = (floor(i_I1) + 1 - i_I1) * (j_I1 - floor(j_I1));                                                             \\\n"
"w00 = (floor(i_I1) + 1 - i_I1) * (floor(j_I1) + 1 - j_I1);\n"
"float computeSSDMeanNorm(const __global uchar *I0_ptr, const __global uchar *I1_ptr,\n"
"int I0_stride, int I1_stride,\n"
"float w00, float w01, float w10, float w11, int patch_sz, int i)\n"
"{\n"
"float sum_diff = 0.0f, sum_diff_sq = 0.0f;\n"
"int n = patch_sz * patch_sz;\n"
"uchar8 I1_vec1, I1_vec2, I0_vec;\n"
"uchar I1_val1, I1_val2;\n"
"I0_vec  = vload8(0, I0_ptr + i * I0_stride);\n"
"I1_vec1 = vload8(0, I1_ptr + i * I1_stride);\n"
"I1_vec2 = vload8(0, I1_ptr + (i + 1) * I1_stride);\n"
"I1_val1 = I1_ptr[i * I1_stride + 8];\n"
"I1_val2 = I1_ptr[(i + 1) * I1_stride + 8];\n"
"float8 vec = w00 * convert_float8(I1_vec1) + w01 * convert_float8((uchar8)(I1_vec1.s123, I1_vec1.s4567, I1_val1)) +\n"
"w10 * convert_float8(I1_vec2) + w11 * convert_float8((uchar8)(I1_vec2.s123, I1_vec2.s4567, I1_val2)) -\n"
"convert_float8(I0_vec);\n"
"sum_diff = (dot(vec.lo, 1.0) + dot(vec.hi, 1.0));\n"
"sum_diff_sq = (dot(vec.lo, vec.lo) + dot(vec.hi, vec.hi));\n"
"sum_diff = sub_group_reduce_add(sum_diff);\n"
"sum_diff_sq = sub_group_reduce_add(sum_diff_sq);\n"
"return sum_diff_sq - sum_diff * sum_diff / n;\n"
"}\n"
"__kernel void dis_patch_inverse_search_fwd_1(__global const float *Ux_ptr, __global const float *Uy_ptr,\n"
"__global const uchar *I0_ptr, __global const uchar *I1_ptr,\n"
"int border_size, int patch_size, int patch_stride,\n"
"int w, int h, int ws, int hs, int pyr_level,\n"
"__global float *Sx_ptr, __global float *Sy_ptr)\n"
"{\n"
"int id = get_global_id(0);\n"
"int is = id / 8;\n"
"if (id >= (hs * 8)) return;\n"
"int i = is * patch_stride;\n"
"int j = 0;\n"
"int psz = patch_size;\n"
"int psz2 = psz / 2;\n"
"int w_ext = w + 2 * border_size;\n"
"int bsz = border_size;\n"
"float i_lower_limit = bsz - psz + 1.0f;\n"
"float i_upper_limit = bsz + h - 1.0f;\n"
"float j_lower_limit = bsz - psz + 1.0f;\n"
"float j_upper_limit = bsz + w - 1.0f;\n"
"float i_I1, j_I1, w00, w01, w10, w11;\n"
"float prev_Ux = Ux_ptr[(i + psz2) * w + j + psz2];\n"
"float prev_Uy = Uy_ptr[(i + psz2) * w + j + psz2];\n"
"Sx_ptr[is * ws] = prev_Ux;\n"
"Sy_ptr[is * ws] = prev_Uy;\n"
"j += patch_stride;\n"
"int sid = get_sub_group_local_id();\n"
"for (int js = 1; js < ws; js++, j += patch_stride)\n"
"{\n"
"float min_SSD, cur_SSD;\n"
"float Ux = Ux_ptr[(i + psz2) * w + j + psz2];\n"
"float Uy = Uy_ptr[(i + psz2) * w + j + psz2];\n"
"INIT_BILINEAR_WEIGHTS(Ux, Uy);\n"
"min_SSD = computeSSDMeanNorm(I0_ptr + i * w + j, I1_ptr + (int)i_I1 * w_ext + (int)j_I1,\n"
"w, w_ext, w00, w01, w10, w11, psz, sid);\n"
"INIT_BILINEAR_WEIGHTS(prev_Ux, prev_Uy);\n"
"cur_SSD = computeSSDMeanNorm(I0_ptr + i * w + j, I1_ptr + (int)i_I1 * w_ext + (int)j_I1,\n"
"w, w_ext, w00, w01, w10, w11, psz, sid);\n"
"if (cur_SSD < min_SSD)\n"
"{\n"
"Ux = prev_Ux;\n"
"Uy = prev_Uy;\n"
"}\n"
"prev_Ux = Ux;\n"
"prev_Uy = Uy;\n"
"Sx_ptr[is * ws + js] = Ux;\n"
"Sy_ptr[is * ws + js] = Uy;\n"
"}\n"
"}\n"
"float3 processPatchMeanNorm(const __global uchar *I0_ptr, const __global uchar *I1_ptr,\n"
"const __global short *I0x_ptr, const __global short *I0y_ptr,\n"
"int I0_stride, int I1_stride, float w00, float w01, float w10,\n"
"float w11, int patch_sz, float x_grad_sum, float y_grad_sum)\n"
"{\n"
"float sum_diff = 0.0, sum_diff_sq = 0.0;\n"
"float sum_I0x_mul = 0.0, sum_I0y_mul = 0.0;\n"
"int n = patch_sz * patch_sz;\n"
"uchar8 I1_vec1, I1_vec2;\n"
"uchar I1_val1, I1_val2;\n"
"for (int i = 0; i < 8; i++)\n"
"{\n"
"uchar8 I0_vec = vload8(0, I0_ptr + i * I0_stride);\n"
"I1_vec1 = (i == 0) ? vload8(0, I1_ptr + i * I1_stride) : I1_vec2;\n"
"I1_vec2 = vload8(0, I1_ptr + (i + 1) * I1_stride);\n"
"I1_val1 = (i == 0) ? I1_ptr[i * I1_stride + patch_sz] : I1_val2;\n"
"I1_val2 = I1_ptr[(i + 1) * I1_stride + patch_sz];\n"
"float8 vec = w00 * convert_float8(I1_vec1) + w01 * convert_float8((uchar8)(I1_vec1.s123, I1_vec1.s4567, I1_val1)) +\n"
"w10 * convert_float8(I1_vec2) + w11 * convert_float8((uchar8)(I1_vec2.s123, I1_vec2.s4567, I1_val2)) -\n"
"convert_float8(I0_vec);\n"
"sum_diff += (dot(vec.lo, 1.0) + dot(vec.hi, 1.0));\n"
"sum_diff_sq += (dot(vec.lo, vec.lo) + dot(vec.hi, vec.hi));\n"
"short8 I0x_vec = vload8(0, I0x_ptr + i * I0_stride);\n"
"short8 I0y_vec = vload8(0, I0y_ptr + i * I0_stride);\n"
"sum_I0x_mul += dot(vec.lo, convert_float4(I0x_vec.lo));\n"
"sum_I0x_mul += dot(vec.hi, convert_float4(I0x_vec.hi));\n"
"sum_I0y_mul += dot(vec.lo, convert_float4(I0y_vec.lo));\n"
"sum_I0y_mul += dot(vec.hi, convert_float4(I0y_vec.hi));\n"
"}\n"
"float dst_dUx = sum_I0x_mul - sum_diff * x_grad_sum / n;\n"
"float dst_dUy = sum_I0y_mul - sum_diff * y_grad_sum / n;\n"
"float SSD = sum_diff_sq - sum_diff * sum_diff / n;\n"
"return (float3)(SSD, dst_dUx, dst_dUy);\n"
"}\n"
"__kernel void dis_patch_inverse_search_fwd_2(__global const float *Ux_ptr, __global const float *Uy_ptr,\n"
"__global const uchar *I0_ptr, __global const uchar *I1_ptr,\n"
"__global const short *I0x_ptr, __global const short *I0y_ptr,\n"
"__global const float *xx_ptr, __global const float *yy_ptr,\n"
"__global const float *xy_ptr,\n"
"__global const float *x_ptr, __global const float *y_ptr,\n"
"int border_size, int patch_size, int patch_stride,\n"
"int w, int h, int ws, int hs, int num_inner_iter, int pyr_level,\n"
"__global float *Sx_ptr, __global float *Sy_ptr)\n"
"{\n"
"int js = get_global_id(0);\n"
"int is = get_global_id(1);\n"
"int i = is * patch_stride;\n"
"int j = js * patch_stride;\n"
"int psz = patch_size;\n"
"int psz2 = psz / 2;\n"
"int w_ext = w + 2 * border_size;\n"
"int bsz = border_size;\n"
"int index = is * ws + js;\n"
"if (js >= ws || is >= hs) return;\n"
"float Ux = Sx_ptr[index];\n"
"float Uy = Sy_ptr[index];\n"
"float cur_Ux = Ux;\n"
"float cur_Uy = Uy;\n"
"float cur_xx = xx_ptr[index];\n"
"float cur_yy = yy_ptr[index];\n"
"float cur_xy = xy_ptr[index];\n"
"float detH = cur_xx * cur_yy - cur_xy * cur_xy;\n"
"if (fabs(detH) < EPS) detH = EPS;\n"
"float invH11 = cur_yy / detH;\n"
"float invH12 = -cur_xy / detH;\n"
"float invH22 = cur_xx / detH;\n"
"float prev_SSD = INF, SSD;\n"
"float x_grad_sum = x_ptr[index];\n"
"float y_grad_sum = y_ptr[index];\n"
"float i_lower_limit = bsz - psz + 1.0f;\n"
"float i_upper_limit = bsz + h - 1.0f;\n"
"float j_lower_limit = bsz - psz + 1.0f;\n"
"float j_upper_limit = bsz + w - 1.0f;\n"
"float dUx, dUy, i_I1, j_I1, w00, w01, w10, w11, dx, dy;\n"
"float3 res;\n"
"for (int t = 0; t < num_inner_iter; t++)\n"
"{\n"
"INIT_BILINEAR_WEIGHTS(cur_Ux, cur_Uy);\n"
"res = processPatchMeanNorm(I0_ptr + i * w + j,\n"
"I1_ptr + (int)i_I1 * w_ext + (int)j_I1, I0x_ptr + i * w + j,\n"
"I0y_ptr + i * w + j, w, w_ext, w00, w01, w10, w11, psz,\n"
"x_grad_sum, y_grad_sum);\n"
"SSD = res.x;\n"
"dUx = res.y;\n"
"dUy = res.z;\n"
"dx = invH11 * dUx + invH12 * dUy;\n"
"dy = invH12 * dUx + invH22 * dUy;\n"
"cur_Ux -= dx;\n"
"cur_Uy -= dy;\n"
"if (SSD >= prev_SSD)\n"
"break;\n"
"prev_SSD = SSD;\n"
"}\n"
"float2 vec = (float2)(cur_Ux - Ux, cur_Uy - Uy);\n"
"if (dot(vec, vec) <= (float)(psz * psz))\n"
"{\n"
"Sx_ptr[index] = cur_Ux;\n"
"Sy_ptr[index] = cur_Uy;\n"
"}\n"
"}\n"
"__kernel void dis_patch_inverse_search_bwd_1(__global const uchar *I0_ptr, __global const uchar *I1_ptr,\n"
"int border_size, int patch_size, int patch_stride,\n"
"int w, int h, int ws, int hs, int pyr_level,\n"
"__global float *Sx_ptr, __global float *Sy_ptr)\n"
"{\n"
"int id = get_global_id(0);\n"
"int is = id / 8;\n"
"if (id >= (hs * 8)) return;\n"
"is = (hs - 1 - is);\n"
"int i = is * patch_stride;\n"
"int j = (ws - 2) * patch_stride;\n"
"int psz = patch_size;\n"
"int psz2 = psz / 2;\n"
"int w_ext = w + 2 * border_size;\n"
"int bsz = border_size;\n"
"float i_lower_limit = bsz - psz + 1.0f;\n"
"float i_upper_limit = bsz + h - 1.0f;\n"
"float j_lower_limit = bsz - psz + 1.0f;\n"
"float j_upper_limit = bsz + w - 1.0f;\n"
"float i_I1, j_I1, w00, w01, w10, w11;\n"
"int sid = get_sub_group_local_id();\n"
"for (int js = (ws - 2); js > -1; js--, j -= patch_stride)\n"
"{\n"
"float min_SSD, cur_SSD;\n"
"float2 Ux = vload2(0, Sx_ptr + is * ws + js);\n"
"float2 Uy = vload2(0, Sy_ptr + is * ws + js);\n"
"INIT_BILINEAR_WEIGHTS(Ux.x, Uy.x);\n"
"min_SSD = computeSSDMeanNorm(I0_ptr + i * w + j, I1_ptr + (int)i_I1 * w_ext + (int)j_I1,\n"
"w, w_ext, w00, w01, w10, w11, psz, sid);\n"
"INIT_BILINEAR_WEIGHTS(Ux.y, Uy.y);\n"
"cur_SSD = computeSSDMeanNorm(I0_ptr + i * w + j, I1_ptr + (int)i_I1 * w_ext + (int)j_I1,\n"
"w, w_ext, w00, w01, w10, w11, psz, sid);\n"
"if (cur_SSD < min_SSD)\n"
"{\n"
"Sx_ptr[is * ws + js] = Ux.y;\n"
"Sy_ptr[is * ws + js] = Uy.y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void dis_patch_inverse_search_bwd_2(__global const uchar *I0_ptr, __global const uchar *I1_ptr,\n"
"__global const short *I0x_ptr, __global const short *I0y_ptr,\n"
"__global const float *xx_ptr, __global const float *yy_ptr,\n"
"__global const float *xy_ptr,\n"
"__global const float *x_ptr, __global const float *y_ptr,\n"
"int border_size, int patch_size, int patch_stride,\n"
"int w, int h, int ws, int hs, int num_inner_iter,\n"
"__global float *Sx_ptr, __global float *Sy_ptr)\n"
"{\n"
"int js = get_global_id(0);\n"
"int is = get_global_id(1);\n"
"if (js >= ws || is >= hs) return;\n"
"js = (ws - 1 - js);\n"
"is = (hs - 1 - is);\n"
"int j = js * patch_stride;\n"
"int i = is * patch_stride;\n"
"int psz = patch_size;\n"
"int psz2 = psz / 2;\n"
"int w_ext = w + 2 * border_size;\n"
"int bsz = border_size;\n"
"int index = is * ws + js;\n"
"float Ux = Sx_ptr[index];\n"
"float Uy = Sy_ptr[index];\n"
"float cur_Ux = Ux;\n"
"float cur_Uy = Uy;\n"
"float cur_xx = xx_ptr[index];\n"
"float cur_yy = yy_ptr[index];\n"
"float cur_xy = xy_ptr[index];\n"
"float detH = cur_xx * cur_yy - cur_xy * cur_xy;\n"
"if (fabs(detH) < EPS) detH = EPS;\n"
"float invH11 = cur_yy / detH;\n"
"float invH12 = -cur_xy / detH;\n"
"float invH22 = cur_xx / detH;\n"
"float prev_SSD = INF, SSD;\n"
"float x_grad_sum = x_ptr[index];\n"
"float y_grad_sum = y_ptr[index];\n"
"float i_lower_limit = bsz - psz + 1.0f;\n"
"float i_upper_limit = bsz + h - 1.0f;\n"
"float j_lower_limit = bsz - psz + 1.0f;\n"
"float j_upper_limit = bsz + w - 1.0f;\n"
"float dUx, dUy, i_I1, j_I1, w00, w01, w10, w11, dx, dy;\n"
"float3 res;\n"
"for (int t = 0; t < num_inner_iter; t++)\n"
"{\n"
"INIT_BILINEAR_WEIGHTS(cur_Ux, cur_Uy);\n"
"res = processPatchMeanNorm(I0_ptr + i * w + j,\n"
"I1_ptr + (int)i_I1 * w_ext + (int)j_I1, I0x_ptr + i * w + j,\n"
"I0y_ptr + i * w + j, w, w_ext, w00, w01, w10, w11, psz,\n"
"x_grad_sum, y_grad_sum);\n"
"SSD = res.x;\n"
"dUx = res.y;\n"
"dUy = res.z;\n"
"dx = invH11 * dUx + invH12 * dUy;\n"
"dy = invH12 * dUx + invH22 * dUy;\n"
"cur_Ux -= dx;\n"
"cur_Uy -= dy;\n"
"if (SSD >= prev_SSD)\n"
"break;\n"
"prev_SSD = SSD;\n"
"}\n"
"float2 vec = (float2)(cur_Ux - Ux, cur_Uy - Uy);\n"
"if ((dot(vec, vec)) <= (float)(psz * psz))\n"
"{\n"
"Sx_ptr[index] = cur_Ux;\n"
"Sy_ptr[index] = cur_Uy;\n"
"}\n"
"}\n"
, "b4a43889f4f3346e29ae36e2502b2821", NULL};
struct cv::ocl::internal::ProgramEntry sparse_matching_gpc_oclsrc={moduleName, "sparse_matching_gpc",
"__kernel void getPatchDescriptor(\n"
"__global const uchar* imgCh0, int ic0step, int ic0off,\n"
"__global const uchar* imgCh1, int ic1step, int ic1off,\n"
"__global const uchar* imgCh2, int ic2step, int ic2off,\n"
"__global uchar* out, int outstep, int outoff,\n"
"const int gh, const int gw, const int PR  )\n"
"{\n"
"const int i = get_global_id(0);\n"
"const int j = get_global_id(1);\n"
"if (i >= gh || j >= gw)\n"
"return;\n"
"__global double* desc = (__global double*)(out + (outstep * (i * gw + j) + outoff));\n"
"const int patchRadius = PR * 2;\n"
"float patch[PATCH_RADIUS_DOUBLED][PATCH_RADIUS_DOUBLED];\n"
"for (int i0 = 0; i0 < patchRadius; ++i0) {\n"
"__global const float* ch0Row = (__global const float*)(imgCh0 + (ic0step * (i + i0) + ic0off + j * sizeof(float)));\n"
"for (int j0 = 0; j0 < patchRadius; ++j0)\n"
"patch[i0][j0] = ch0Row[j0];\n"
"}\n"
"#pragma unroll\n"
"for (int n0 = 0; n0 < 4; ++n0) {\n"
"#pragma unroll\n"
"for (int n1 = 0; n1 < 4; ++n1) {\n"
"double sum = 0;\n"
"for (int i0 = 0; i0 < patchRadius; ++i0)\n"
"for (int j0 = 0; j0 < patchRadius; ++j0)\n"
"sum += patch[i0][j0] * cos(CV_PI * (i0 + 0.5) * n0 / patchRadius) * cos(CV_PI * (j0 + 0.5) * n1 / patchRadius);\n"
"desc[n0 * 4 + n1] = sum / PR;\n"
"}\n"
"}\n"
"for (int k = 0; k < 4; ++k) {\n"
"desc[k] *= SQRT2_INV;\n"
"desc[k * 4] *= SQRT2_INV;\n"
"}\n"
"double sum = 0;\n"
"for (int i0 = 0; i0 < patchRadius; ++i0) {\n"
"__global const float* ch1Row = (__global const float*)(imgCh1 + (ic1step * (i + i0) + ic1off + j * sizeof(float)));\n"
"for (int j0 = 0; j0 < patchRadius; ++j0)\n"
"sum += ch1Row[j0];\n"
"}\n"
"desc[16] = sum / patchRadius;\n"
"sum = 0;\n"
"for (int i0 = 0; i0 < patchRadius; ++i0) {\n"
"__global const float* ch2Row = (__global const float*)(imgCh2 + (ic2step * (i + i0) + ic2off + j * sizeof(float)));\n"
"for (int j0 = 0; j0 < patchRadius; ++j0)\n"
"sum += ch2Row[j0];\n"
"}\n"
"desc[17] = sum / patchRadius;\n"
"}\n"
, "4de6dbd7b34900887da8399ec2e431b0", NULL};
struct cv::ocl::internal::ProgramEntry updatemotionhistory_oclsrc={moduleName, "updatemotionhistory",
"__kernel void updateMotionHistory(__global const uchar * silh, int silh_step, int silh_offset,\n"
"__global uchar * mhiptr, int mhi_step, int mhi_offset, int mhi_rows, int mhi_cols,\n"
"float timestamp, float delbound)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < mhi_cols && y < mhi_rows)\n"
"{\n"
"int silh_index = mad24(y, silh_step, silh_offset + x);\n"
"int mhi_index = mad24(y, mhi_step, mhi_offset + x * (int)sizeof(float));\n"
"silh += silh_index;\n"
"__global float * mhi = (__global float *)(mhiptr + mhi_index);\n"
"float val = mhi[0];\n"
"val = silh[0] ? timestamp : val < delbound ? 0 : val;\n"
"mhi[0] = val;\n"
"}\n"
"}\n"
, "b19beb01d0c6052524049341b55a2be5", NULL};

}}}
#endif
